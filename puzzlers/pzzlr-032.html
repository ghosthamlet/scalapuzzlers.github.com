<h1>Two's Company</h1>
<table class="table meta-table table-condensed">
  <tbody>
    <tr>
      <td class="header-column"><strong>Contributed by</strong></td>
      <td>Andrew Phillips</td>
    </tr>
    <tr>
      <td><strong>Source</strong></td>
      <td><a target="_blank" href="https://groups.google.com/forum/#!msg/scala-language/OWTVHhsP3JU/Kyb8h2SqnS4J">scala-lang mailing list</a></td>
    </tr>
    <tr>
      <td><strong>Tested with Scala version</strong></td>
      <td>2.10.0</td>
    </tr>
  </tbody>
</table>
<div class="code-snippet">
  <h3>What is the result of executing the following code?</h3>
<pre class="prettyprint lang-scala">
trait Settings { def title: String }
implicit val D = new Settings { val title = "default" }

println("Title: " + implicitly[Settings].title)
{
  implicit val T = new Settings { val title = "test" }
  println("Title: " + implicitly[Settings].title)
}
</pre>
  <ol>
    <li id="correct-answer">The first prints:
<pre class="prettyprint lang-scala">
Title: default
</pre>
and the second fails with a compilation error
    </li>
    <li>Prints:
<pre class="prettyprint lang-scala">
Title: default
Title: test
</pre>
    </li>
<pre class="prettyprint lang-scala">
Title: default
Title: default
</pre>
    <li>Prints:
<pre class="prettyprint lang-scala">
Title: test
Title: test
</pre>
    </li>
  </ol>
</div>
<button id="show-and-tell" class="btn btn-primary" href="#">Display the correct answer, explanation and comments</button>
<div id="explanation" class="explanation" style="display:none">
  <h3>Explanation</h3>
  <p>
    According to <a href="http://www.scala-lang.org/docu/files/ScalaReference.pdf" target="_blank">SLS §7.2</a>:
    <blockquote>If there are several eligible arguments which match the implicit parameter’s type, a most specifc one will be chosen using the rules of static overloading resolution (§6.26.3).</blockquote>
    If the rules for static overloading resolution cannot determine a most specific type, this results in an error, as is the case here:
<pre class="prettyprint lang-scala">
&lt;console&gt;:16: error: ambiguous implicit values:
 both value D of type => Settings{val title: String}
 and value T of type Settings{val title: String}
 match expected type Settings
                println("Title: " + implicitly[Settings].title)
</pre>
    So far, so unremarkably according to the spec. What is puzzling here is that importing an implicit in an inner scope does not override the &quot;default&quot; declaration in the outer scope, even though implicits are often intended to be &quot;overridden&quot; in this way.
  <p>
    Of course, if we choose the same <em>name</em> for the &quot;overridding&quot;</p> implicit, we achieve the intended result:
<pre class="prettyprint lang-scala">
...
{
  implicit val D = new Settings { val title = "test" }
  println("Title: " + implicitly[Settings].title)
}
Title: test
</pre>
    This is because <em>name</em> resultion, unlike implicit resolution, means that <tt>D</tt> declared in the inner scope has higher precedence than the default value in the outer scope.
  <p>
    Thus, if we happen to know the <em>name</em> of the implicit we are trying to &quot;override&quot;, we can achieve the intended result. But since implicits are &quot;anonymous&quot; practically by definition, having to know the <em>name</em> of one to be able to override it seems an odd requirement.
  </p>
  <p>If the default implicit is provided by external code, where its name might change at any time, this results in brittle code, too. At least the &quot;ambiguous implicit values&quot;error message helpfully provides the name of the implicit that we need to override.
  </p>
  <p>
    See the <a href="https://groups.google.com/d/topic/scala-language/OWTVHhsP3JU/discussion" target="_blank">scala-lang thread</a> for further discussion.
  </p>
</div>